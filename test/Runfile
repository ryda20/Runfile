#!/bin/bash
source ${RF_DIR:-~/.Runfile}/Runfile.template # MUST_START_OF_FILE
##regison USER ===================================================

fn_list_by() {
	# include_fn is a list of "start_with" string need to be keep in return list
	# if include_fn is empty: mean include all
	# Ex: "keep_me rf_"
	local include_fn=${1:-""} # priority 1
	# exclude_fn is a list of "start_with" string need to be exclude in return list
	# if exclude_fn is empty: mean does not exclude
	# Ex: "_ rf_"
	local exclude_fn=${2:-""} # priority 2
	
	# declare -F return all function name with format: 
	#	declare -F fname1
	#	declare -F fname2
	#	.......
	#	declare -F fnameN
	local _rf_fn_list=$(echo $(declare -F) | sed 's/declare -f //g')
	local str=""
	local repos_dir=${RF_REPOS_DIR:-"~/.Runfile"}
	local fname aliasfile description
	#
	# echo "${include_fn}"
	for f in ${_rf_fn_list}; do
		# check include list
		if [[ -n "${include_fn}" ]]; then
			# IFS=$' ' # make sure IFS = space
			for i in ${include_fn}; do
				# echo "include value: ${i}"
				# echo "included: $f -> "$( _fn_str_prefix "$f" "alias_" )""
					
				if [[ "${f:0:${#i}}" == "${i}" ]]; then
					####
					if [[ "$( _fn_str_prefix "$f" "alias_" )" == "yes" ]]; then
						fname="${f}"
						# get descriptition.  how?
						# find a alias file in plugins dir and echo it path to cat out content,
						# then send to sed and find the matching, remove the matching part,
						# then print out (by -n and p) the description
						aliasfile=$( find ${repos_dir}/plugins -type f -name 'alias_*_1' -exec echo {} \; )
						description="$( cat ${aliasfile} | sed -n "s|^#${fname}: ||p" )"
						if [[ -n ${description} ]]; then
							fname="$( echo ${fname} | sed 's|alias_||' ) (${description})"
						else
							fname="$( echo ${fname} | sed 's|alias_||' )"
						fi
						description=""
						# echo "-> full fname: $fname"
						f="${fname}"
					fi
					#####
					str="${str}${f}"$'\n'
					continue 2 # skip this for and continue on parent for loop
				fi
			done
			continue
		fi
		# check exclude list
		if [[ -n "${exclude_fn}" ]]; then
			for e in ${exclude_fn}; do
				# get the first value in f with len of exclude and then compare to exclude value, skip if it same
				# ex: exclude = "tf_" 		-> len = 3
				#	  f = "tf_log_title"	-> ${f:0:len} = tf_
				if [[ "${f:0:${#e}}" == "${e}" ]]; then continue 2; fi
			done
		fi
		
		# normally case
		str="${str}${f}"$'\n'
	done
	# return string
	echo "${str}"
}
fn() {
	local str=$( fn_list_by "alias_ rf_" "" )
	
	

	local saveIFS="$IFS"
	IFS=$'\n'
	local arr=( ${str} )
	local idx=0
	echo "len: ${#arr}"
	for line in ${str}; do
		echo "${idx} - line: ${line}"
		idx=$((idx+1))
	done
	IFS="$saveIFS"
	
}
abc() {
	echo "Abc task"
	local x
	x1=${1:-${x:-100}}
	echo "x1: $x1"
}

exitcode() {
	echo "this task will failed"
	( exit 33 ) # return exit code without close shell - actualy exit sub shell
}

# test variable scope
# -> varialbe x can be change inside tt function and sub function
# but outside is not change, it like inside function it create another 
# variable x after the line: x="first"
x="out"
tt() {
	echo -e "[tt] init: x=$x"
	x="first"
	echo -e "[tt] changed: x=$x"
	tt1() {
		echo -e "\t[tt1] x=$x"
		x="second"
		echo -e "\t[tt1] =$x"
	}
	tt1
	echo -e "[tt]=$x => changed inside: $( [[ "$x" == "out" ]] && echo "no" || echo "yes" )"
}
tt_check() {
	echo -e "changed outside? $( [[ "$x" != "out" ]] && echo "no" || echo "yes" )"
}

tt2() {
	echo -e "[tt2] init: x=$x"
	local x="first"
	echo -e "[tt2] changed: x=$x"
	tt22() {
		echo -e "\t[tt22] x=$x"
		x="second"
		echo -e "\t[tt22] =$x"
	}
	tt22
	echo -e "[tt2]=$x => changed: $( [[ "$x" == "out" ]] && echo "no" || echo "yes" )"
}

fn2() {
	# declare - Set variable values and attributes
	# 	NAME
	# declare - Set variable values and attributes.
	# SYNOPSIS
	#
	# declare [-aAfFgilnrtux] [-p] [name[=value] ...]
	# DESCRIPTION
	#
	# Set variable values and attributes.
	# Declare variables and give them attributes. If no NAMEs are given, display the attributes and values of all variables.
	#
	# Options:
	#
	# -f
	# restrict action or display to function names and definitions
	# -F
	# restrict display to function names only (plus line number and source file when debugging)
	# -g
	# create global variables when used in a shell function; otherwise ignored
	# -p
	# display the attributes and value of each NAME
	# Options which set attributes:
	#
	# -a
	# to make NAMEs indexed arrays (if supported)
	# -A
	# to make NAMEs associative arrays (if supported)
	# -i
	# to make NAMEs have the ‘integer’ attribute
	# -l
	# to convert NAMEs to lower case on assignment
	# -n
	# make NAME a reference to the variable named by its value
	# -r
	# to make NAMEs readonly
	# -t
	# to make NAMEs have the ‘trace’ attribute
	# -u
	# to convert NAMEs to upper case on assignment
	# -x
	# to make NAMEs export
	# Using ‘+’ instead of ‘-’ turns off the given attribute.
	#
	# Variables with the integer attribute have arithmetic evaluation (see the let command) performed when the variable is assigned a value.
	#
	# When used in a function, declare makes NAMEs local, as with the local command. The ‘-g’ option suppresses this behavior.
	#
	# Exit Status:
	# Returns success unless an invalid option is supplied or a variable assignment error occurs.

	declare a b c
	a=foo
	b=bar
	c=baz

	foo () {
		echo "1. From within func:"
		declare -p a
		declare -p b
		declare -p c


		local a=1 b=2 c=3

		echo "2. From within func:"
		declare -p a
		declare -p b
		declare -p c
	}

	foo

	echo "From outside func:"
	declare -p a
	declare -p b
	declare -p c
}

fn2() {
	declare -i a -a b c
	a=foo
	b=(bar)
	c=baz

	foo () {
		local -i a=1 -a b=(2) c=3

		echo "From within func:"
		declare -p a
		declare -p b
		declare -p c
	}

	foo

	echo "From outside func:"
	declare -p a
	declare -p b
	declare -p c
}

test() {
	list="$( find ~/.Runfile/plugins -type f -name 'alias_*_1' -exec echo "{}" \; )"
	cat $list
}
##endregion USER =================================================
__start_app ${@} # MUST_END_OF_FILE
