#!/bin/bash -i
RF_DIR=${RF_DIR:-~/.Runfile} # get RF_DIR from ENV or using default value
source ${RF_DIR}/vars

# only include file end with _1 (enable), _0 (disable)
for f in ${RF_DIR}/plugins/*_1; do
	# echo "loading: $f"
	source ${f}
done


# _fn_list_by return a string "func1 func2 func3 ...." with condition input
_fn_list_by() {
	# include_fn is a list of "start_with" string need to be keep in return list
	# if include_fn is empty: mean include all
	# Ex: "keep_me rf_"
	local include_fn=${1:-""} # priority 1
	# exclude_fn is a list of "start_with" string need to be exclude in return list
	# if exclude_fn is empty: mean does not exclude
	# Ex: "_ rf_"
	local exclude_fn=${2:-""} # priority 2
	

	# declare -F return all function name with format: 
	#	declare -F fname1
	#	declare -F fname2
	#	.......
	#	declare -F fnameN
	local _rf_fn_list=$(echo $(declare -F) | sed 's/declare -f //g')
	local str=""
	#
	for f in ${_rf_fn_list}; do
		# check include list
		if [[ -n "${include_fn}" ]]; then
			for i in ${include_fn}; do
				if [[ "${f:0:${#i}}" == "${i}" ]]; then
					str="${str}${f} "
					continue 2 # skip this for and continue on parent for loop
				fi
			done
			continue
		fi
		# check exclude list
		if [[ -n "${exclude_fn}" ]]; then
			for e in ${exclude_fn}; do
				# get the first value in f with len of exclude and then compare to exclude value, skip if it same
				# ex: exclude = "tf_" 		-> len = 3
				#	  f = "tf_log_title"	-> ${f:0:len} = tf_
				if [[ "${f:0:${#e}}" == "${e}" ]]; then continue 2; fi
			done
		fi
		
		# normally case
		str="${str}${f} "
	done
	# return by echo
	echo "${str}"
}

_fn_row_format() {
	local arr=${1}
	local alias=${2:-""}
	local arr_len=${#arr[@]}
	local idx=0
	local columns=${COLUMN_NUMBER}
	local description=""
	local rowX=""
	local padding=$(( LINE_LEN / columns - 4 )) # -4 because we added 4 char `%2d) ` and we don't want to increse line len more
	for (( i=0; i < arr_len; i+=columns)); do
		rowX="# " # `# ` 	-> + 2 chars
		for (( j=0; j < columns; j++ )); do
			idx=$(( i + j ))
			if (( idx < arr_len )); then
				fname=${arr[idx]}
				if [[ ${alias} == "alias" ]]; then
					# get descriptition.  how?
					# find a alias file in plugins dir and echo it path to cat out content,
					# then send to sed and find the matching, remove the matching part,
					# then print out (by -n and p) the description
					description=$(cat $(find ${RF_DIR}/plugins -type f -name 'alias_*_1'  -exec echo {} \;) | sed -n "s|^#${fname}: ||p")
					if [[ -n ${description} ]]; then
						fname="$(echo ${fname} | sed 's|alias_||' ) (${description})"
					else
						fname="$(echo ${fname} | sed 's|alias_||' )"
					fi
					description=""
				fi
				# `%2d )` -> + 4 chars
				rowX="${rowX}$( printf "%2d) %-${padding}s" $(( idx + 1 )) "${fname}" )"
			else
				# still keep space for "x) " - 4 spaces for formating correctly
				rowX="${rowX}$( printf "    %-${padding}s" "" )"
			fi
		done
		rowX="$rowX#\n" # `\n`	-> + 2 chars
	done
	echo "$rowX"
}
# _fn_list show list of available functions
_fn_list() {
	local include_fn=${1:-""}
	local exclude_fn=${2:-""}
	local title=${3:-"all fn(s)"}
	local alias=${4:-""}

	# list functions formated by printf
	local rowLen=0
	local rowX=0
	local fnList=""
	local str=$(_fn_list_by "${include_fn}" "${exclude_fn}")
	local arr=(${str}) # convert string "x y z" to array
	local arr_len=${#arr[@]}
	local idx=0
	local columns=${COLUMN_NUMBER}
	local description=""
	# if [[ ${alias} == "alias" ]]; then columns=6; fi
	local padding=$(( LINE_LEN / columns - 4 )) # -4 because we added 4 char `%2d) ` and we don't want to increse line len more
	
	if [[ ${arr_len} -eq 0 ]]; then
		rf_log " not found any fn(s). Run: \`run help\` to see all defined fn(s)"
		return;
	fi
	
	for (( i=0; i < arr_len; i+=columns)); do
		local rowX="# " # `# ` 	-> + 2 chars
		for (( j=0; j < columns; j++ )); do
			idx=$(( i + j ))
			if (( ${idx} < ${arr_len} )); then
				fname=${arr[idx]}
				if [[ ${alias} == "alias" ]]; then
					# get descriptition.  how?
					# find a alias file in plugins dir and echo it path to cat out content,
					# then send to sed and find the matching, remove the matching part,
					# then print out (by -n and p) the description
					description=$(cat $(find ${RF_DIR}/plugins -type f -name 'alias_*_1'  -exec echo {} \;) | sed -n "s|^#${fname}: ||p")
					if [[ -n ${description} ]]; then
						fname="$(echo ${fname} | sed 's|alias_||' ) (${description})"
					else
						fname="$(echo ${fname} | sed 's|alias_||' )"
					fi
					description=""
				fi
				# `%2d )` -> + 4 chars
				rowX="${rowX}$( printf "%2d) %-${padding}s" $(( idx + 1 )) "${fname}" )"
			else
				# still keep space for "x) " - 4 spaces for formating correctly
				rowX="${rowX}$( printf "    %-${padding}s" "" )"
			fi
		done
		rowX="$rowX#\n" # `\n`	-> + 2 chars
		# set row len to send to rf_log_xxx
		# - 4 because we add 4 chars and we want to keep LINE_LEN
		# and set only one time because rows len is equal
		# and must to subtract because some of chars does not display, so, the display will not true (\n)
		if (( rowLen == 0 )); then rowLen=$(( ${#rowX} - 4 )); fi
		fnList="${fnList}${rowX}"
	done
	fnList="${fnList%'\n'}" # remove 2 chars at end of string out '\n', or using: ${out%??}
	
	rf_log_title "${title}" "${fnList}" "no" ${rowLen}
}

help() {
	local str="
run <fn_name> <args>
run help alias <prefix>
	=> to show alias fn list only,
	=> prefix: run help alias go -> only show alias start with goxxxx
run help rf
	=> to show internal rf fn only
"
	local cmd=${1}
	local alias_filter=${2}

	if [[ "${cmd}" == "alias" ]]; then
		# show alias
		_fn_list "alias_${alias_filter}" "" "alias fn(s)" "alias"
		return
	fi
	if [[ "${cmd}" == "rf" ]]; then
		_fn_list "rf_" "" "rf fn(s)"
		return
	fi

	# else, show all
	if [[ "${MODE}" == "loop" ]]; then _fn_exit_msg; fi
	# rf_log_title "Usage" "${str}"
	#
	# _fn_list "rf_" "" "runfile fn(s)"
	# _fn_list "alias_" "" "alias fn(s)" "alias"
	_fn_list "" "_ rf_ alias_" "user fn(s)"
}


# __fn_list_check_normal will check input command and validation before execute
# run with command: `run task args`
__fn_list_check_normal () {
	local cmd="${1}";shift
	local args="$@"

	# if no input: ${#cmd} -eq 0. Nothing to check 
	# -> show user functions only
	# -> hide functions start with _ and rf_ and alias_
	if [[ -z "${cmd}" ]]; then
		_fn_list "" "_ rf_ alias_" "user fn(s)"
		return
	fi
	
	# check if the ${cmd} available or not (build-in command or user command, functions, alias function)
	# https://stackoverflow.com/questions/592620/how-can-i-check-if-a-program-exists-from-a-bash-script
	# check if $cmd is a valid command
	if [[ -n $( command -v ${cmd} ) ]]; then
		# execute the command with args
		eval ${cmd} "${args}"
	elif [[ -n $( command -v alias_${cmd} ) ]]; then
		# execute alias function with args
		eval alias_${cmd} "${args}"
	else
		echo "command \"${cmd}\" couln't be found!"
	fi
	
}

_fn_exit_msg() {
	rf_log_title "cmd(s)" "
	q: quit
	r: reload session"
}

_fn_reload() {
	clear && exec bash -c "${RUNFILE_FILE}"
}


_fn_git_exist() {
	if [[ -n "$( command -v git )" ]] && [[ -d "${RUNFILE_DIR}/.git" ]]; then 
		echo "yes"
	fi
	echo ""
}
_GIT_EXIST="$(_fn_git_exist)"
_fn_git_info_start() {
	local gitstr=""
	if [[ -n "${_GIT_EXIST}" ]]; then 
		gitstr="git:("
	fi
	echo "${BLUE}${gitstr}"
}
_fn_git_info_mid(){
	local gitstr=""
	if [[ -n "${_GIT_EXIST}" ]]; then 
		gitstr="$( git rev-parse --abbrev-ref HEAD )"
	fi
	echo "${RED}${gitstr}"
}
_fn_git_info_end() {
	local gitstr=""
	if [[ -n "${_GIT_EXIST}" ]]; then 
		gitstr=") "
	fi
	echo "${BLUE}${gitstr}"
}
#STATUS=$(__git_prompt_git status ${FLAGS} 2> /dev/null | tail -n 1)
_fn_git_status() {
	local gitstr=""
	if [[ -n "${_GIT_EXIST}" ]]; then 
		status=$(git status --porcelain --untracked-files=no --ignore-submodules=dirty | tail -n 1)
		if [[ -n "$status" ]]; then
			gitstr="${RED}✗ "
		else
			gitstr="${GREEN}✔ "
		fi
	fi
	echo "${gitstr}"
}

# __fn_list_check_loop will check input command and validation before execute
# run with command: `run`, then user can call task by type `task_name args`
__fn_list_check_loop() {
	#
	_fn_exit_msg

	local cmd=""
	local args=""
	# return user functions and build-in function, exclude internal function (start with _)
	local __fn_list=$(_fn_list_by "" "_")
	
	# make a copy of Runfile
	if [[ "${AUTO_RELOAD}" == "yes" ]]; then
		rm -rf "${RUNFILE_FILE_BK}"
		cp "${RUNFILE_FILE}" "${RUNFILE_FILE_BK}"
	fi
	#
	local path_for=""
	local path_now=""
	local path_pre=""
	#
	local git_info_start=$(_fn_git_info_start)
	local git_info_end=$(_fn_git_info_end)
	local sign=$( if [[ "$USER" != "root" ]]; then echo "${BLUE}\$ "; else echo "${RED}\# "; fi )
	
	local arrow="${GREEN}➜ [r] "
	
	
	
	while true ; do

		# check if Runfile changed
		if [[ "${AUTO_RELOAD}" == "yes" ]] && [[ "${RUNFILE_FILE}" -nt "$RUNFILE_FILE_BK" ]]; then
			#echo "Runfile was changed"
			_fn_reload
		fi
		path_now=$( pwd )
		if [[ "${path_pre}" != "${path_now}" ]]; then
			path_pre="${path_now}"
			#
			path_for="$( echo "${path_now}" | sed -e s@$HOME@'~'@g )"
			path_for="$( basename ${path_for} ) "
		fi
		
		# -e for tab completion on dir or file name
		read -e -p "${arrow}${path_for}${git_info_start}$( _fn_git_info_mid )${git_info_end}$(_fn_git_status)${sign}${COLOR_RESET}" cmd args
		

		case $cmd in
			q) exit 0;;
			r) _fn_reload;;
			*)
				# if no input: ${#cmd} -eq 0. Nothing to check 
				# -> show user functions only
				# -> hide functions start with _ and rf_ and alias_
				if [[ -z "${cmd}" ]]; then
					time _fn_list "" "_ rf_ alias_" "user fn(s)"
					echo
					continue
				fi
				
				# check if the ${cmd} available or not (build-in command or user command, functions, alias function)
				# https://stackoverflow.com/questions/592620/how-can-i-check-if-a-program-exists-from-a-bash-script
				# check if $cmd is a valid command
				if [[ -n $( command -v ${cmd} ) ]]; then
					# execute the command with args
					time eval ${cmd} "${args}"
				elif [[ -n $( command -v alias_${cmd} ) ]]; then
					# execute alias function with args
					time eval alias_${cmd} "${args}"
				else
					echo "command \"${cmd}\" couln't be found!"
				fi
		esac
	done
}


# __start_app must to call this function at the end of user Runfile
__start_app() {
	if [[ "${MODE}" == "loop" ]]; then
		__fn_list_check_loop "$@"
	else
		time __fn_list_check_normal "$@"
	fi
}
