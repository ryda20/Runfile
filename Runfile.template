#!/bin/bash -i
RF_REPOS_DIR=${RF_REPOS_DIR:-~/.Runfile} # get RF_REPOS_DIR from ENV or using default value
source ${RF_REPOS_DIR}/vars
source ${RF_REPOS_DIR}/utils

# only include file end with _1 (enable), _0 (disable)
for f in ${RF_REPOS_DIR}/plugins/*_1; do
	# echo "loading: $f"
	source ${f}
done


# _fn_list_by return a string "func1 func2 func3 ...." with condition input
_fn_list_by() {
	# include_fn is a list of "start_with" string need to be keep in return list
	# if include_fn is empty: mean include all
	# Ex: "keep_me rf_"
	local include_fn=${1:-""} # priority 1
	# exclude_fn is a list of "start_with" string need to be exclude in return list
	# if exclude_fn is empty: mean does not exclude
	# Ex: "_ rf_"
	local exclude_fn=${2:-""} # priority 2
	

	# declare -F return all function name with format: 
	#	declare -F fname1
	#	declare -F fname2
	#	.......
	#	declare -F fnameN
	local _rf_fn_list=$(echo $(declare -F) | sed 's/declare -f //g')
	local str=""
	#
	for f in ${_rf_fn_list}; do
		# check include list
		if [[ -n "${include_fn}" ]]; then
			for i in ${include_fn}; do
				if [[ "${f:0:${#i}}" == "${i}" ]]; then
					str="${str}${f} "
					continue 2 # skip this for and continue on parent for loop
				fi
			done
			continue
		fi
		# check exclude list
		if [[ -n "${exclude_fn}" ]]; then
			for e in ${exclude_fn}; do
				# get the first value in f with len of exclude and then compare to exclude value, skip if it same
				# ex: exclude = "tf_" 		-> len = 3
				#	  f = "tf_log_title"	-> ${f:0:len} = tf_
				if [[ "${f:0:${#e}}" == "${e}" ]]; then continue 2; fi
			done
		fi
		
		# normally case
		str="${str}${f} "
	done
	# return by echo
	echo "${str}"
}

# _fn_list show list of available functions
_fn_list() {
	local include_fn=${1:-""}
	local exclude_fn=${2:-""}
	local title=${3:-"all fn(s)"}
	local alias=${4:-""}

	# list functions formated by printf
	local rowLen=0 rowX fname idx=0 fnList=""
	local arr=($(_fn_list_by "${include_fn}" "${exclude_fn}")) # convert return string "x y z" to array by wrapped ()
	local arr_len=${#arr[@]}
	local columns=${RF_COLUMN_NUMB:-3}
	local line_width=${RF_LINE_WIDTH:-100}
	local description=""
	local repos_dir=${RF_REPOS_DIR:-"~/.Runfile"}
	# if [[ ${alias} == "alias" ]]; then columns=6; fi
	local padding=$(( line_width / columns + 2 )) # plus 2 to always ceiling padding


	if [[ ${arr_len} -eq 0 ]]; then
		rf_log " not found any fn(s). Run: \`run help\` to see all defined fn(s)"
		return;
	fi
	
	for (( i=0; i < arr_len; i+=columns)); do
		rowX=""
		for (( j=0; j < columns; j++ )); do
			idx=$(( i + j ))
			if (( ${idx} < ${arr_len} )); then
				fname=${arr[idx]}
				if [[ ${alias} == "alias" ]]; then
					# get descriptition.  how?
					# find a alias file in plugins dir and echo it path to cat out content,
					# then send to sed and find the matching, remove the matching part,
					# then print out (by -n and p) the description
					aliasfile=$( find ${repos_dir}/plugins -type f -name 'alias_*_1' -exec echo {} \; )
					description="$( cat ${aliasfile} | sed -n "s|^#${fname}: ||p" )"
					if [[ -n ${description} ]]; then
						fname="$( echo ${fname} | sed 's|alias_||' ) (${description})"
					else
						fname="$( echo ${fname} | sed 's|alias_||' )"
					fi
					description=""
				fi
				rowX="${rowX}$( printf "%2d) %-${padding}s" $(( idx + 1 )) "${fname}" )"
			else
				#  last rowX, keep padding 
				rowX="${rowX}$( printf "    %-${padding}s" " " )"
			fi
		done
		rowX="$rowX"$'\n'
		if (( rowLen < ${#rowX} )); then rowLen=$(( ${#rowX} )); fi
		fnList="${fnList}${rowX}"
	done
	fnList="${fnList%'\n'}" # remove 2 chars at end of string out '\n', or using: ${out%??}
	
	rf_log_title "${title}" "${fnList}" ${rowLen}
}

_fn_list_bk() {
	local include_fn=${1:-""}
	local exclude_fn=${2:-""}
	local title=${3:-"all fn(s)"}
	local alias=${4:-""}

	# list functions formated by printf
	local rowLen=0
	local rowX=0
	local fnList=""
	local str=$(_fn_list_by "${include_fn}" "${exclude_fn}")
	local arr=(${str}) # convert string "x y z" to array
	local arr_len=${#arr[@]}
	local idx=0
	local columns=${RF_COLUMN_NUMB:-3}
	local line_width=${RF_LINE_WIDTH:-100}
	local description=""
	local repos_dir=${RF_REPOS_DIR:-"~/.Runfile"}
	# if [[ ${alias} == "alias" ]]; then columns=6; fi
	local padding=$(( line_width / columns - 4 )) # -4 because we added 4 char `%2d) ` and we don't want to increse line len more
	
	if [[ ${arr_len} -eq 0 ]]; then
		rf_log " not found any fn(s). Run: \`run help\` to see all defined fn(s)"
		return;
	fi
	
	for (( i=0; i < arr_len; i+=columns)); do
		local rowX="# " # `# ` 	-> + 2 chars
		for (( j=0; j < columns; j++ )); do
			idx=$(( i + j ))
			if (( ${idx} < ${arr_len} )); then
				fname=${arr[idx]}
				if [[ ${alias} == "alias" ]]; then
					# get descriptition.  how?
					# find a alias file in plugins dir and echo it path to cat out content,
					# then send to sed and find the matching, remove the matching part,
					# then print out (by -n and p) the description
					aliasfile=$( find ${repos_dir}/plugins -type f -name 'alias_*_1' -exec echo {} \; )
					description="$( cat ${aliasfile} | sed -n "s|^#${fname}: ||p" )"
					if [[ -n ${description} ]]; then
						fname="$(echo ${fname} | sed 's|alias_||' ) (${description})"
					else
						fname="$(echo ${fname} | sed 's|alias_||' )"
					fi
					description=""
				fi
				# `%2d )` -> + 4 chars
				rowX="${rowX}$( printf "%2d) %-${padding}s" $(( idx + 1 )) "${fname}" )"
			else
				# still keep space for "x) " - 4 spaces for formating correctly
				rowX="${rowX}$( printf "    %-${padding}s" "" )"
			fi
		done
		rowX="$rowX#\n" # `\n`	-> + 2 chars
		# set row len to send to rf_log_xxx
		# - 4 because we add 4 chars and we want to keep line width
		# and set only one time because rows len is equal
		# and must to subtract because some of chars does not display, so, the display will not true (\n)
		if (( rowLen < ${#rowX} )); then rowLen=$(( ${#rowX} - 4 )); fi
		fnList="${fnList}${rowX}"
	done
	fnList="${fnList%'\n'}" # remove 2 chars at end of string out '\n', or using: ${out%??}
	
	rf_log_title "${title}" "${fnList}" "no" ${rowLen}
}

help() {
	local str="
run <fn_name> <args>
run help alias <prefix>
	=> to show alias fn list only,
	=> prefix: run help alias go -> only show alias start with goxxxx
run help rf
	=> to show internal rf fn only
"
	local cmd=${1}
	local alias_filter=${2}

	if [[ "${cmd}" == "alias" ]]; then
		# show alias
		_fn_list "alias_${alias_filter}" "" "alias fn(s)" "alias"
		return
	fi
	if [[ "${cmd}" == "rf" ]]; then
		_fn_list "rf_" "" "rf fn(s)"
		return
	fi

	local mode=${RF_MODE:-"loop"}
	# else, show all
	if [[ "${mode}" == "loop" ]]; then _fn_exit_msg; fi
	# rf_log_title "Usage" "${str}"
	#
	_fn_list "rf_" "" "runfile fn(s)"
	_fn_list "alias_" "" "alias fn(s)" "alias"
	_fn_list "" "_ rf_ alias_" "user fn(s)"
}


# __fn_list_check_normal will check input command and validation before execute
# run with command: `run task args`
__fn_list_check_normal () {
	local cmd="${1}";shift
	local args="$@"

	# if no input: ${#cmd} -eq 0. Nothing to check 
	# -> show user functions only
	# -> hide functions start with _ and rf_ and alias_
	if [[ -z "${cmd}" ]]; then
		_fn_list "" "_ rf_ alias_" "user fn(s)"
		return
	fi
	
	# check if the ${cmd} available or not (build-in command or user command, functions, alias function)
	# https://stackoverflow.com/questions/592620/how-can-i-check-if-a-program-exists-from-a-bash-script
	# check if $cmd is a valid command
	if [[ -n $( command -v ${cmd} ) ]]; then
		# execute the command with args
		eval ${cmd} "${args}"
	elif [[ -n $( command -v alias_${cmd} ) ]]; then
		# execute alias function with args
		eval alias_${cmd} "${args}"
	else
		echo "command \"${cmd}\" couln't be found!"
	fi
	
}

_fn_exit_msg() {
	rf_log_title "cmd(s)" "
	q: quit
	r: reload session
	h: help
"
}

_fn_reload() {
	clear && exec bash -c "${RF_WORKING_DIR}/Runfile"
}




# __fn_list_check_loop will check input command and validation before execute
# run with command: `run`, then user can call task by type `task_name args`
__fn_list_check_loop() {
	#
	_fn_exit_msg

	declare cmd args
	# return user functions and build-in function, exclude internal function (start with _)
	__fn_list=$(_fn_list_by "" "_")
	
	#
	local path path_now path_pre
	__path_auto_format(){
		path_now=$( pwd )
		if [[ "${path_pre}" != "${path_now}" ]]; then
			path_pre="${path_now}"
			#
			path="$( echo "${path_now}" | sed -e s@$HOME@'~'@g )"
			path="${RF_GREEN}$( basename ${path} ) "
		fi
	}
	#
	local arrow_red="${RF_RED}➜ [r] " arrow_green="${RF_GREEN}➜ [r] "
	local arrow="${arrow_green}"
	__arrow_auto_set() {
		local exitcode=$?
		[[ $exitcode -gt 0 ]] && arrow=${arrow_red} || arrow=${arrow_green}
	}
	
	_fn_git_exist() {
		[[ -n "${RF_GIT}" ]] && [[ -d "$( pwd )/.git" ]] && echo "yes"
	}

	_fn_git_info_start() {
		[[ -n "$( _fn_git_exist )" ]] && echo "${RF_BLUE}git:("
	}
	local git_info_start="$(_fn_git_info_start)"

	_fn_git_info_mid(){
		[[ -n "$( _fn_git_exist )" ]] && echo "${RF_RED}$( git rev-parse --abbrev-ref HEAD )"
	}

	_fn_git_info_end() {
		[[ -n "$( _fn_git_exist )" ]] && echo "${RF_BLUE}) "
	}
	local git_info_end="$(_fn_git_info_end)"

	_fn_git_status() {
		[[ -z "$( _fn_git_exist )" ]] && echo -n "" || echo "$( [[ -n "$(git status --porcelain --untracked-files=no --ignore-submodules=dirty | tail -n 1)" ]] && echo "${RF_RED}✗ " || echo "${RF_GREEN}✔ " )"
	}

	local dollar_char=$( if [[ "$USER" != "root" ]]; then echo "${RF_BLUE}\$"; else echo "${RF_RED}\#"; fi )
	
	# make a copy of Runfile
	local runfilebk="/tmp/RunfileBk"
	local autoreload=${RF_AUTO_RELOAD:-"yes"}
	if [[ "${autoreload}" == "yes" ]]; then
		rm -rf "${runfilebk}"
		cp "${RF_WORKING_DIR}/Runfile" "${runfilebk}"
	fi

	while true ; do

		# check if Runfile changed
		if [[ "${autoreload}" == "yes" ]] && [[ "${RF_WORKING_DIR}/Runfile" -nt "$runfilebk" ]]; then
			#echo "Runfile was changed"
			_fn_reload
		fi

		__path_auto_format
		
		# -e for tab completion on dir or file name => it make error below
		# got error: Terminal prompt not wrapping correctly
		# read -p "${BRIGHT}${arrow}${path}$( _fn_git_info_start )$( _fn_git_info_mid )$( _fn_git_info_end )$( _fn_git_status )${final_sign}${NORMAL} " cmd args
		#
		# below have small error like above but happend in the second line
		# echo -en "${BRIGHT}${arrow}${path}$( _fn_git_info_start )$( _fn_git_info_mid )$( _fn_git_info_end )$( _fn_git_status )${final_sign}${NORMAL}"
		# read -e -p " " cmd args
		#
		# below is work ok
		read -p "${RF_BRIGHT}${arrow}${path}$( _fn_git_info_start )$( _fn_git_info_mid )$( _fn_git_info_end )$( _fn_git_status )${final_sign}${RF_NORMAL} " cmd args
		

		case $cmd in
			q) exit 0;;
			r) _fn_reload;;
			h) help;;
			*)
				# if no input: ${#cmd} -eq 0. Nothing to check 
				# -> show user functions only
				# -> hide functions start with _ and rf_ and alias_
				if [[ -z "${cmd}" ]]; then
					time _fn_list "" "_ rf_ alias_" "user fn(s)"
					echo
					continue
				fi
				
				# check if the ${cmd} available or not (build-in command or user command, functions, alias function)
				# https://stackoverflow.com/questions/592620/how-can-i-check-if-a-program-exists-from-a-bash-script
				# check if $cmd is a valid command
				if [[ -n $( command -v ${cmd} ) ]]; then
					# execute the command with args
					time eval ${cmd} "${args}"
				elif [[ -n $( command -v alias_${cmd} ) ]]; then
					# execute alias function with args
					time eval alias_${cmd} "${args}"
				else
					echo "command \"${cmd}\" couln't be found!"
					# set $? - return code without exit shell
					# actually it run in subshell and exit subshell
					( exit 1 ) 
				fi
				__arrow_auto_set
		esac
	done
}


# __start_app must to call this function at the end of user Runfile
__start_app() {
	local mode=${RF_MODE:-"loop"}
	if [[ "${mode}" == "loop" ]]; then
		__fn_list_check_loop
	else
		time __fn_list_check_normal "$@"
	fi
}
