#!/bin/bash -i
RF_REPOS_DIR=${RF_REPOS_DIR:-~/.Runfile} # get RF_REPOS_DIR from ENV or using default value
source ${RF_REPOS_DIR}/vars
source ${RF_REPOS_DIR}/utils

# only include file end with _1 (enable), _0 (disable)
for f in ${RF_REPOS_DIR}/plugins/*_1; do
	# echo "loading: $f"
	source ${f}
done


# _fn_list_by return a string "func1 func2 func3 ...." with condition input
_fn_list_by() {
	# include_fn is a list of "start_with" string need to be keep in return list
	# if include_fn is empty: mean include all
	# Ex: "keep_me rf_" - seperated by space
	local include_fn=${1:-""} # priority 1
	# exclude_fn is a list of "start_with" string need to be exclude in return list
	# if exclude_fn is empty: mean does not exclude
	# Ex: "_ rf_" - seperated by space
	local exclude_fn=${2:-""} # priority 2
	
	local SEP=${3:-$'\n'}

	# declare -F return all function name with format: 
	#	declare -F fname1
	#	declare -F fname2
	#	.......
	#	declare -F fnameN
	local _rf_fn_list=$(echo $(declare -F) | sed 's/declare -f //g')
	local str=""
	local repos_dir=${RF_REPOS_DIR:-"~/.Runfile"}
	local aliasfile description
	#
	for f in ${_rf_fn_list}; do
		if [[ -n "${include_fn}" ]]; then
			for i in ${include_fn}; do
				if [[ "${f:0:${#i}}" == "${i}" ]]; then
					# find description for alias
					if [[ "$( _fn_str_prefix "$f" "alias_" )" == "yes" ]]; then
						# how?
						# find a alias file in plugins dir and echo it path to cat out content,
						# then send to sed and find the matching, remove the matching part,
						# then print out (by -n and p) the description
						aliasfile=$( find ${repos_dir}/plugins -type f -name 'alias_*_1' -exec echo {} \; )
						description="$( cat ${aliasfile} | sed -n "s|^#${f}: ||p" )"
						if [[ -n ${description} ]]; then
							f="$( echo ${f} | sed 's|alias_||' ) (${description})"
						else
							f="$( echo ${f} | sed 's|alias_||' )"
						fi
						description=""
					fi
					str="${str}${f}"${SEP}
					continue 2 # skip this for and continue on parent for loop
				fi
			done
			continue
		fi
		# check exclude list
		if [[ -n "${exclude_fn}" ]]; then
			for e in ${exclude_fn}; do
				# get the first value in f with len of exclude and then compare to exclude value, skip if it same
				# ex: exclude = "tf_" 		-> len = 3
				#	  f = "tf_log_title"	-> ${f:0:len} = tf_
				if [[ "${f:0:${#e}}" == "${e}" ]]; then continue 2; fi
			done
		fi
		
		# normally case
		str="${str}${f}"${SEP}
	done
	# return string
	echo "${str}"
}

# _fn_list show list of available functions
_fn_list() {
	local include_fn=${1:-""}
	local exclude_fn=${2:-""}
	local title=${3:-"all fn(s)"}
	local alias=${4:-""}
	#
	local columns=${RF_COLUMN_NUMB:-3}
	local line_width=${RF_LINE_WIDTH:-100}
	local padding=$(( line_width / columns + 2 )) # plus 2 to always ceiling padding
	local repos_dir=${RF_REPOS_DIR:-"~/.Runfile"}
	#
	#
	local SEP=$'\n'
	local str=$( _fn_list_by "${include_fn}" "${exclude_fn}" ${SEP} ) # return string with seperated is \n
	# find len of array by seperated in str
	local arr arr_len=0
	local saveIFS="$IFS" && IFS="$SEP"
	for line in ${str}; do 
		arr[${arr_len}]="${line}"
		arr_len=$(( arr_len+1 ))
	done && IFS="$saveIFS"
	# echo "len ${arr_len}"
	
	local rowLen=0 rowX fname idx=0 fnList="" description=""

	if [[ ${arr_len} -eq 0 ]]; then
		rf_log " not found any fn(s). Run: \`run help\` to see all defined fn(s)"
		return;
	fi
	
	for (( i=0; i < arr_len; i+=columns)); do
		rowX=""
		for (( j=0; j < columns; j++ )); do
			idx=$(( i + j ))
			if (( ${idx} < ${arr_len} )); then
				fname=${arr[idx]}
				rowX="${rowX}$( printf "%2d) %-${padding}s" $(( idx + 1 )) "${fname}" )"
			else
				#  last rowX, keep padding 
				rowX="${rowX}$( printf "    %-${padding}s" " " )"
			fi
		done
		rowX="${rowX}${SEP}"
		if (( rowLen < ${#rowX} )); then rowLen=$(( ${#rowX} )); fi
		fnList="${fnList}${rowX}"
	done
	fnList="${fnList%${SEP}}" # remove 2 chars at end of string out '\n', or using: ${out%??}
	
	rf_log_title "${title}" "${fnList}" ${rowLen}
}

help() {
	local str="
run <fn_name> <args>
run help alias <prefix>
	=> to show alias fn list only,
	=> prefix: run help alias go -> only show alias start with goxxxx
run help rf
	=> to show internal rf fn only
"
	local cmd=${1}
	local alias_filter=${2}

	if [[ "${cmd}" == "alias" ]]; then
		# show alias
		_fn_list "alias_${alias_filter}" "" "alias fn(s)" "alias"
		return
	fi
	if [[ "${cmd}" == "rf" ]]; then
		_fn_list "rf_" "" "rf fn(s)"
		return
	fi

	local mode=${RF_MODE:-"loop"}
	# else, show all
	if [[ "${mode}" == "loop" ]]; then _fn_exit_msg; fi
	# rf_log_title "Usage" "${str}"
	#
	_fn_list "rf_" "" "runfile fn(s)"
	_fn_list "alias_" "" "alias fn(s)" "alias"
	_fn_list "" "_ rf_ alias_" "user fn(s)"
}


# __fn_list_check_normal will check input command and validation before execute
# run with command: `run task args`
__fn_list_check_normal () {
	local cmd="${1}";shift
	local args="$@"

	# if no input: ${#cmd} -eq 0. Nothing to check 
	# -> show user functions only
	# -> hide functions start with _ and rf_ and alias_
	if [[ -z "${cmd}" ]]; then
		_fn_list "" "_ rf_ alias_" "user fn(s)"
		return
	fi
	
	# check if the ${cmd} available or not (build-in command or user command, functions, alias function)
	# https://stackoverflow.com/questions/592620/how-can-i-check-if-a-program-exists-from-a-bash-script
	# check if $cmd is a valid command
	if [[ -n $( command -v ${cmd} ) ]]; then
		# execute the command with args
		eval ${cmd} "${args}"
	elif [[ -n $( command -v alias_${cmd} ) ]]; then
		# execute alias function with args
		eval alias_${cmd} "${args}"
	else
		echo "command \"${cmd}\" couln't be found!"
	fi
	
}

_fn_exit_msg() {
	local msg="
	q: quit
	r: reload session
	h: go working dir
"
	rf_log_title "cmd(s)" "${msg}"
}

_fn_reload() {
	clear
	cd $RF_WORKING_DIR
	exec bash -c "${RF_WORKING_DIR}/Runfile"
}




# __fn_list_check_loop will check input command and validation before execute
# run with command: `run`, then user can call task by type `task_name args`
__fn_list_check_loop() {
	#
	_fn_exit_msg

	declare cmd args
	# return user functions and build-in function, exclude internal function (start with _)
	__fn_list=$(_fn_list_by "" "_")
	
	#
	local path path_now path_pre
	__path_auto_format(){
		path_now=$( pwd )
		if [[ "${path_pre}" != "${path_now}" ]]; then
			path_pre="${path_now}"
			#
			path="$( echo "${path_now}" | sed -e "s@$HOME@~@g" )"
			path="${RF_GREEN}$( basename ${path} ) "
		fi
	}
	#
	_fn_short_dir() { 
		local path=${1:-""}
		local replace_home_path=${2:-"yes"}
		local keep=${3:-1}
		
		if [[ -z "${path}" ]]; then return; fi

		if [[ "${replace_home_path}" == "yes" ]]; then
			path=$( echo "${path}" | sed "s@$HOME@~@g" )
		fi   
		dir=${path%/*} # remove /* at the end of $1 - like dirname function do
		last=${path##*/} # remove */ at the first of $1 - like basename function do

		# ${dir//\// } => # replace / with " " -> //find_string/replace_string
		# ${dir} | sed "s|/| |g" => # replace / witt " "
		res=$(
			for i in ${dir//\// } ; do
				# echo out $keep chars from first one and dont make newline (-n)
				echo -n "${i:0:${keep}}/";
			done
		)                                                                                                                                                                                                            
		echo "$res$last"                                                                                                                                                                                                                                                         
	}
	_fn_in_working_dir() {
		[[ $( pwd ) == ${RF_WORKING_DIR}* ]] && echo "yes"
		# [[ $a == z* ]]   # True if $a starts with a "z" (wildcard matching).
		# [[ $a == "z*" ]] # True if $a is equal to z* (literal matching).
	}
	#
	_fn_rf_dir() {
		# h: stand for home working directory
		if [[ "$( pwd )" == "${RF_WORKING_DIR}" ]]; then
			echo "h"
		elif [[ -n "$( _fn_in_working_dir )" ]]; then
			echo $( pwd ) | sed "s|^${RF_WORKING_DIR}|h|"
		else
			local p=$( echo "${RF_WORKING_DIR}" | sed "s@$HOME@~@g" )
			p=$( _fn_short_dir "${p}" )
			echo "${p}"
		fi
	}
	#
	
	_fn_arrow_red() {
		echo "${RF_RED}➜ [$( _fn_rf_dir )] "
	}
	_fn_arrow_green() {
		echo "${RF_GREEN}➜ [$( _fn_rf_dir )] "
	}
	local arrow="$( _fn_arrow_green )"
	__arrow_auto_set() {
		[[ $? -gt 0 ]] && arrow="$( _fn_arrow_red )" || arrow="$( _fn_arrow_green )"
	}
	#
	_fn_git_dir_exist() {
		if [[ -z "${RF_GIT}" ]]; then
			return
		fi
		if [[ -d "$( pwd )/.git" ]]; then
			echo "yes"
		elif [[ -n "$( _fn_in_working_dir )" ]] && [[ -d "${RF_WORKING_DIR}/.git" ]]; then
			echo "yes"
		fi
	}
	_fn_git_info_start() {
		[[ -n "$( _fn_git_dir_exist )" ]] && echo "${RF_BLUE}git:("
	}
	_fn_git_info_mid(){
		[[ -n "$( _fn_git_dir_exist )" ]] && echo "${RF_RED}$( git rev-parse --abbrev-ref HEAD )"
	}
	_fn_git_info_end() {
		[[ -n "$( _fn_git_dir_exist )" ]] && echo "${RF_BLUE}) "
	}
	_fn_git_status() {
		[[ -z "$( _fn_git_dir_exist )" ]] && echo -n "" || echo "$( [[ -n "$(git status --porcelain --untracked-files=no --ignore-submodules=dirty | tail -n 1)" ]] && echo "${RF_RED}✗ " || echo "${RF_GREEN}✔ " )"
	}

	local final_sign=$( if [[ "$USER" != "root" ]]; then echo "${RF_BLUE}\$"; else echo "${RF_RED}\#"; fi )
	
	# make a copy of Runfile
	local runfilebk="/tmp/RunfileBk"
	local autoreload=${RF_AUTO_RELOAD:-"yes"}
	if [[ "${autoreload}" == "yes" ]]; then
		rm -rf "${runfilebk}"
		cp "${RF_WORKING_DIR}/Runfile" "${runfilebk}"
	fi

	while true ; do

		# check if Runfile changed
		if [[ "${autoreload}" == "yes" ]] && [[ "${RF_WORKING_DIR}/Runfile" -nt "$runfilebk" ]]; then
			#echo "Runfile was changed"
			_fn_reload
		fi

		__path_auto_format
		
		# -e for tab completion on dir or file name => it make error below
		# got error: Terminal prompt not wrapping correctly
		# read -p "${BRIGHT}${arrow}${path}$( _fn_git_info_start )$( _fn_git_info_mid )$( _fn_git_info_end )$( _fn_git_status )${final_sign}${NORMAL} " cmd args
		#
		# below have small error like above but happend in the second line
		# echo -en "${BRIGHT}${arrow}${path}$( _fn_git_info_start )$( _fn_git_info_mid )$( _fn_git_info_end )$( _fn_git_status )${final_sign}${NORMAL}"
		# read -e -p " " cmd args
		#
		# below is work ok
		read -e -p "${RF_BRIGHT}${arrow}${path}$( _fn_git_info_start )$( _fn_git_info_mid )$( _fn_git_info_end )$( _fn_git_status )${final_sign}${RF_NORMAL} " cmd args
		

		case $cmd in
			q) exit 0;;
			r) _fn_reload;;
			rr) rf_update "local" "/Users/ddnm/gitlab/ryda20/Runfile" && _fn_reload ;;
			h) cd $RF_WORKING_DIR;;
			*)
				# if no input: ${#cmd} -eq 0. Nothing to check 
				# -> show user functions only
				# -> hide functions start with _ and rf_ and alias_
				if [[ -z "${cmd}" ]]; then
					time _fn_list "" "_ rf_ alias_" "user fn(s)"
					echo
					continue
				fi
				
				# check if the ${cmd} available or not (build-in command or user command, functions, alias function)
				# https://stackoverflow.com/questions/592620/how-can-i-check-if-a-program-exists-from-a-bash-script
				# check if $cmd is a valid command
				if [[ -n $( command -v ${cmd} ) ]]; then
					# execute the command with args
					time eval ${cmd} "${args}"
				elif [[ -n $( command -v alias_${cmd} ) ]]; then
					# execute alias function with args
					time eval alias_${cmd} "${args}"
				else
					echo "command \"${cmd}\" couln't be found!"
					# set $? - return code without exit shell
					# actually it run in subshell and exit subshell
					( exit 1 ) 
				fi
				__arrow_auto_set
		esac
	done
}


# __start_app must to call this function at the end of user Runfile
__start_app() {
	local mode=${RF_MODE:-"loop"}
	if [[ "${mode}" == "loop" ]]; then
		__fn_list_check_loop
	else
		time __fn_list_check_normal "$@"
	fi
}
