#!/bin/bash
RF_DIR=${RF_DIR:-~/.Runfile} # get RF_DIR from ENV or using default value
source ${RF_DIR}/vars

# only include file end with _1 (enable), _0 (disable)
for f in ${RF_DIR}/plugins/*_1; do
	# echo "loading: $f"
	source ${f}
done


# _fn_list_by return a string "func1 func2 func3 ...." with condition input
_fn_list_by() {
	# include_fn is a list of "start_with" string need to be keep in return list
	# if include_fn is empty: mean include all
	# Ex: "keep_me rf_"
	local include_fn=${1:-""} # priority 1
	# exclude_fn is a list of "start_with" string need to be exclude in return list
	# if exclude_fn is empty: mean does not exclude
	# Ex: "_ rf_"
	local exclude_fn=${2:-""} # priority 2
	

	# declare -F return all function name with format: 
	#	declare -F fname1
	#	declare -F fname2
	#	.......
	#	declare -F fnameN
	local _rf_fn_list=$(echo $(declare -F) | sed 's/declare -f //g')
	local str=""
	#
	for f in ${_rf_fn_list}; do
		# check include list
		if [[ -n "${include_fn}" ]]; then
			for i in ${include_fn}; do
				if [[ "${f:0:${#i}}" == "${i}" ]]; then
					str="${str}${f} "
					continue 2 # skip this for and continue on parent for loop
				fi
			done
			continue
		fi
		# check exclude list
		if [[ -n "${exclude_fn}" ]]; then
			for e in ${exclude_fn}; do
				# get the first value in f with len of exclude and then compare to exclude value, skip if it same
				# ex: exclude = "tf_" 		-> len = 3
				#	  f = "tf_log_title"	-> ${f:0:len} = tf_
				if [[ "${f:0:${#e}}" == "${e}" ]]; then continue 2; fi
			done
		fi
		
		# normally case
		str="${str}${f} "
	done
	# return by echo
	echo "${str}"
}

# _fn_list show list of available functions
_fn_list() {
	local include_fn=${1:-""}
	local exclude_fn=${2:-""}
	local title=${3:-"all fn(s)"}
	local alias=${4:-""}

	# list functions formated by printf
	local fnList=""
	local str=$(_fn_list_by "${include_fn}" "${exclude_fn}")
	local arr=(${str}) # convert string "x y z" to array
	local arr_len=${#arr[@]}
	local idx=0
	local columns=${COLUMN_NUMBER}
	if [[ ${alias} == "alias" ]]; then columns=6; fi
	rowLen=0
	local padding=$(( LINE_LEN / columns - 4 )) # -4 because we added 4 char `%2d) ` and we don't want to increse line len more
	for (( i=0; i < arr_len; i+=columns)); do
		local rowX="# " # `# ` 	-> + 2 chars
		for (( j=0; j < columns; j++ )); do
			idx=$(( i + j ))
			if (( ${idx} < ${arr_len} )); then
				fname=${arr[idx]}
				if [[ ${alias} == "alias" ]]; then
					fname=$(echo ${fname} | sed 's|alias_||' )
				fi
				# `%2d )` -> + 4 chars
				rowX="${rowX}$( printf "%2d) %-${padding}s" ${idx} ${fname} )"
			else
				# still keep space for "x) " - 4 spaces for formating correctly
				rowX="${rowX}$( printf "    %-${padding}s" "" )"
			fi
		done
		rowX="$rowX#\n" # `\n`	-> + 2 chars
		# set row len to send to rf_log_xxx
		# - 4 because we add 4 chars and we want to keep LINE_LEN
		# and set only one time because rows len is equal
		# and must to subtract because some of chars does not display, so, the display will not true (\n)
		if (( rowLen == 0 )); then rowLen=$(( ${#rowX} - 4 )); fi
		fnList="${fnList}${rowX}"
	done
	fnList="${fnList%'\n'}" # remove 2 chars at end of string out '\n', or using: ${out%??}
	# echo "rowlen: $rowLen, padding: $padding,"
	rf_log_title "${title}" "${fnList}" "no" ${rowLen}
}


help() {
	local str="
$0 <task> <args>
	or simple (by alias run=$0):
run <task> <args>
"
	rf_log_title "Usage" "${str}"
	#
	_fn_list "rf_" "" "runfile fn(s)"
	_fn_list "alias_" "" "alias fn(s)" "alias"
	_fn_list "" "_ rf_ alias_" "user fn(s)"
}


# __fn_list_check will check input command and validation before execute
# dont change this function name to ensure the app works after you update.
# if you want to change, make sure change in Runfile (time __fn_list_check), too
__fn_list_check() {
	local cmd=${1}; shift
	local args=$@

	# if no input: ${#cmd} -eq 0. Nothing to check 
	# -> show user functions only
	# -> hide functions start with _ and rf_
	if [[ -z "${cmd}" ]]; then
		_fn_list "alias_" "" "alias fn(s)" "alias"
		_fn_list "" "_ rf_ alias_" "user fn(s)"
		exit 0
	fi

	# return user functions and build-in function, exclude internal function (start with _)
	local __fn_list=$(_fn_list_by "" "_")

	# check for alias first, if not have, check for normally function
	# check ${cmd} to see if it available in fn_list
	# note: we add space before and after __fn_list and first_cmd to make sure we are compairing full word
	# because we will go wrong if:
	# ex: __fn_list = "abc edf ght dgr"
	# Case : cmd = ab or df or gr,... -> command will valid (because we use * in comparation)
	# Fix:
	# __fn_list = " abc edf ght dgr "
	# cmd = " search " =>
	# " abc " -> valid, but
	# " ab " -> not valid
	if [[ " ${__fn_list} " == *" alias_${cmd} "* ]]; then
		# echo "command \`${cmd}\` is alias"
		# call alias
		alias_${cmd} ${args}
	elif [[ " ${__fn_list} " != *" ${cmd} "* ]]; then
		echo "command \`${cmd}\` is not valid"
		exit 1
	else
		# echo "valid command: ${cmd} ${args}"
		${cmd} ${args}
	fi
}



# __start_app must to call this function at the end of user Runfile
__start_app() {
	time __fn_list_check ${@}
}
