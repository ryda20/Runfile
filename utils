#!/bin/bash

rf_version() {
	echo $(date '+%Y%m%d%H%M%S') > version.txt
}

# rf_check_update will check if it available in new verion
rf_check_update() {
	rf_log_prefix="update"
	#
	local rf_repos_dir=${RF_REPOS_DIR:-~/Runfile}
	local rversion=$(curl -fsSL https://gitlab.com/ryda20/runfile/-/raw/master/version.txt)
	local lversion=$(cat "${rf_repos_dir}/version.txt")
	if [[ "${rversion}" != "${lversion}" ]]; then
		read -p "A new version is available. Do you want to update? [Y/n]" answer
		[[ "${answer}" == "Y" ]] && rf_update || echo "nothing changed"
	else
		rf_log_header "You have latest version"
	fi
}

# _rf_update run update runfile
rf_update() {
	local mode="${1}"
	local dir="${2:-.}"
	#
	local rf_repos_dir=${RF_REPOS_DIR:-~/Runfile}
	if [[ "${mode}" == "local" ]]; then
		#local install
		bash ${dir}/install.sh local
	else
		bash "${rf_repos_dir}/install.sh" update
	fi
}

# rf_copy_ex2 copy rf_ex2 to user Runfile
# wip - not completed
_rf_copy_ex2() {
	if [[ "$(pwd)" == "${RF_REPOS_DIR}" ]]; then
		rf_log "do not copy tmpl fn to template Runfile"
		exit 0
	fi
	
	# cat plugins/rf_ex2_tmpl_1 >> ./Runfile
}
# rf_copy_ex1 copy rf_ex2 to user Runfile
# wip - not completed
_rf_copy_ex1() {
	if [[ "$(pwd)" == "${RF_REPOS_DIR}" ]]; then
		rf_log "do not copy tmpl fn to template Runfile"
		exit 0
	fi
	
	copy=$(cat ${RF_REPOS_DIR}/plugins/rf_ex1_tmpl_1 | sed '/^#!.*$/d')
	echo $copy
	f="./Runfile"
	# still error because in $copy have many special like (), {}, :,....
	cp ${f} ${f}.tmp && \
	sed -e "s|^##endregion USER.*$|\$\{copy\}\n&|" <${f}.tmp >${f} && \
	rm -f ${f}.tmp
	if [[ $? -eq 0 ]]; then
		rf_log "sucessfully"
	else
		rf_log "not sucessfully"
		cp ${f}.tmp ${f}
		rm ${f}.tmp
	fi
}

# rf_dir_recurse loop & print a folder recusively,
# and will return to caller when return value != 0
rf_dir_recurse() {
	local dir=${1:-"."}
	local fnFileCallback=${2:-}
	local fnDirCallback=${3:-}
    for f in "${dir}"/*;do
        if [ -d "${f}" ] && [[ -n "${f}" ]]; then
			if [[ -n ${fnDirCallback} ]]; then
				# call the callback function and pass current directory path to it
				fnDirCallback ${f}
				if [[ $? != 0 ]]; then
					return $?
				fi
			fi
			rf_dir_recurse "${f}"
		elif [ -f "${f}" ] ; then
			if [[ -n ${fnFileCallback} ]]; then
				# call the callback function and pass current directory path to it
				fnFileCallback ${f}
				if [[ $? != 0 ]]; then
					return $?
				fi
			fi
		fi
    done
}
